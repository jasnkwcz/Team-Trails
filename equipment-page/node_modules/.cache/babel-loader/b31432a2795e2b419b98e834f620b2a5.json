{"ast":null,"code":"\"use strict\";\n\nimport { transitionEnd, setToken, debounce } from \"./helpers.mjs\";\nimport { default as Fold, folds } from \"./fold.mjs\";\nconst accordions = [];\nlet activeAccordions = 0;\nlet lastResizeRate;\n/**\n * Represents a column of collapsible content regions.\n * @class\n */\n\nexport default class Accordion {\n  /**\n   * Instantiate a new Accordion instance.\n   *\n   * @param {HTMLElement} el                    - Container wrapped around each immediate fold\n   * @param {Object}      options               - Optional hash of settings\n   * @param {String}      options.openClass     - CSS class controlling each fold's \"open\" state\n   * @param {String}      options.closeClass    - CSS class used to mark a fold as closed\n   * @param {String}      options.edgeClass     - CSS class toggled based on whether the bottom-edge is visible\n   * @param {String}      options.snapClass     - CSS class for disabling transitions between window resizes\n   * @param {String}      options.enabledClass  - CSS class marking an accordion as enabled\n   * @param {String}      options.disabledClass - CSS class marking an accordion as disabled\n   * @param {Boolean}     options.disabled      - Whether to disable the accordion on creation\n   * @param {Boolean}     options.modal         - Whether to close the current fold when opening another\n   * @param {Boolean}     options.noAria        - Disable the addition and management of ARIA attributes\n   * @param {Boolean}     options.noKeys        - Disable keyboard navigation\n   * @param {Boolean}     options.noTransforms  - Disable CSS transforms; positioning will be used instead\n   * @param {Number}      options.heightOffset  - Distance to offset each fold by\n   * @param {Boolean}     options.useBorders    - Consider borders when calculating fold heights\n   * @param {Function}    options.onToggle      - Callback executed when opening or closing a fold\n   * @constructor\n   */\n  constructor(el, options) {\n    this.index = accordions.push(this) - 1; // Parse options\n\n    options = options || {};\n    this.openClass = options.openClass || \"open\";\n    this.closeClass = options.closeClass || \"closed\";\n    this.edgeClass = undefined === options.edgeClass ? \"edge-visible\" : options.edgeClass;\n    this.snapClass = undefined === options.snapClass ? \"snap\" : options.snapClass;\n    this.enabledClass = undefined === options.enabledClass ? \"accordion\" : options.enabledClass;\n    this.disabledClass = options.disabledClass;\n    this.modal = !!options.modal;\n    this.noAria = !!options.noAria;\n    this.noKeys = !!options.noKeys;\n    this.noTransforms = !!options.noTransforms;\n    this.heightOffset = +options.heightOffset || 0;\n    this.useBorders = undefined === options.useBorders ? \"auto\" : options.useBorders;\n    this.onToggle = options.onToggle; // Create a fold for each immediate descendant of the Accordion's container\n\n    let folds = [];\n\n    for (let i of Array.from(el.children)) {\n      let fold = new Fold(this, i);\n      folds.push(fold); // Connect the fold to its previous sibling, if it's not the first to be added\n\n      let prev = folds[folds.length - 2];\n\n      if (prev) {\n        prev.nextFold = fold;\n        fold.previousFold = prev;\n      }\n    }\n\n    el.accordion = this.index;\n    this.noAria || el.setAttribute(\"role\", \"tablist\");\n    this.el = el;\n    this.folds = folds; // Add .enabledClass early - it might affect the heights of each fold\n\n    if (!options.disabled && this.enabledClass) el.classList.add(this.enabledClass);\n    this.update(); // Find out if this accordion's nested inside another\n\n    let next = el;\n\n    while ((next = next.parentNode) && 1 === next.nodeType) {\n      let fold = Accordion.getFold(next);\n\n      if (fold) {\n        let accordion = fold.accordion;\n        this.parent = accordion;\n        this.parentFold = fold;\n        this.edgeClass && el.classList.remove(this.edgeClass);\n        (accordion.childAccordions = accordion.childAccordions || []).push(this);\n        (fold.childAccordions = fold.childAccordions || []).push(this); // Adjust the height of the containing fold's element\n\n        if (fold.open) {\n          let scrollHeight = fold.el.scrollHeight;\n          let distance = fold.headingHeight + fold.content.scrollHeight - scrollHeight || scrollHeight - fold.el.clientHeight;\n          accordion.updateFold(fold, distance);\n        }\n\n        break;\n      }\n    }\n\n    this.edgeClass && this.el.addEventListener(transitionEnd, this.onTransitionEnd = e => {\n      if (!this.parent && e.target === el && \"height\" === e.propertyName && el.getBoundingClientRect().bottom > window.innerHeight) el.classList.remove(this.edgeClass);\n    });\n    this.disabled = !!options.disabled;\n  }\n  /**\n   * Get or set the accordion enclosing this one.\n   *\n   * @property\n   * @type {Accordion}\n   */\n\n\n  set parent(input) {\n    this._parent = input;\n  }\n\n  get parent() {\n    let result = this._parent;\n    if (!result) return null; // Search for the first ancestor that *isn't* disabled\n\n    while (result) {\n      if (!result.disabled) return result;\n      result = result.parent;\n    }\n\n    return null;\n  }\n  /**\n   * Get or set the fold of the accordion enclosing this one.\n   *\n   * @property\n   * @type {Fold}\n   */\n\n\n  set parentFold(input) {\n    this._parentFold = input;\n  }\n\n  get parentFold() {\n    let fold = this._parentFold;\n    if (!fold) return null;\n    let accordion = fold.accordion; // Search for the first ancestor that *isn't* disabled\n\n    while (fold && accordion) {\n      if (!accordion.disabled) return fold;\n      if (accordion = accordion.parent) fold = accordion.parentFold;\n    }\n\n    return null;\n  }\n  /**\n   * Whether the accordion's been deactivated.\n   *\n   * @property\n   * @type {Boolean}\n   */\n\n\n  get disabled() {\n    return this._disabled;\n  }\n\n  set disabled(input) {\n    if ((input = !!input) !== this._disabled) {\n      const el = this.el;\n      const style = el.style;\n      const classes = el.classList;\n      this.enabledClass && setToken(classes, this.enabledClass, !input);\n      this.disabledClass && setToken(classes, this.disabledClass, input); // Deactivating\n\n      if (this._disabled = input) {\n        style.height = null;\n        this.snapClass && classes.remove(this.snapClass);\n\n        if (this.edgeClass) {\n          el.removeEventListener(transitionEnd, this.onTransitionEnd);\n          classes.remove(this.edgeClass);\n        }\n\n        for (let i of this.folds) i.disabled = true;\n\n        this.noAria || el.removeAttribute(\"role\");\n        --activeAccordions;\n      } // Reactivating\n      else {\n          for (let i of this.folds) i.disabled = false;\n\n          this.noAria || el.setAttribute(\"role\", \"tablist\");\n          ++activeAccordions;\n          this.update();\n        } // If there're no more active accordions, disable the onResize handler\n\n\n      if (activeAccordions <= 0) {\n        activeAccordions = 0;\n        Accordion.setResizeRate(false);\n      } // Otherwise, reactivate the onResize handler, assuming it was previously active\n      else if (lastResizeRate) Accordion.setResizeRate(lastResizeRate);\n    }\n  }\n  /**\n   * Height of the accordion's container element.\n   *\n   * @property\n   * @type {Number}\n   */\n\n\n  get height() {\n    return this._height;\n  }\n\n  set height(input) {\n    if (input && (input = +input) !== this._height) {\n      this.el.style.height = input + \"px\";\n      this._height = input;\n    }\n  }\n  /**\n   * Internal method to check if an accordion's bottom-edge is visible to the user (or about to be).\n   *\n   * @param {Number} offset\n   * @private\n   */\n\n\n  edgeCheck(offset) {\n    let edgeClass = this.edgeClass;\n\n    if (edgeClass) {\n      let box = this.el.getBoundingClientRect();\n      let windowEdge = window.innerHeight;\n      let classes = this.el.classList; // If the bottom-edge is visible (or about to be), enable height animation\n\n      if (box.bottom + (offset || 0) < windowEdge) classes.add(edgeClass); // If the bottom-edge isn't visible anyway, disable height animation immediately\n      else if (box.bottom > windowEdge) classes.remove(edgeClass);\n    }\n  }\n  /**\n   * Update the vertical ordinate of each sibling for a particular fold.\n   *\n   * @param {Fold} fold\n   * @param {Number} offset - Pixel distance to adjust by\n   */\n\n\n  updateFold(fold, offset) {\n    let next = fold;\n    let parentFold = this.parentFold;\n\n    while (next = next.nextFold) next.y += offset;\n\n    parentFold || this.edgeCheck(offset);\n    fold.height += offset;\n    this.height += offset;\n    parentFold && parentFold.open && this.parent.updateFold(parentFold, offset);\n  }\n  /**\n   * Update the height of each fold to fit its content.\n   */\n\n\n  update() {\n    let y = 0;\n    let height = 0;\n\n    for (let i of this.folds) {\n      i.y = y;\n      i.fit();\n      y += i.height;\n      height += i.height;\n    }\n\n    let parentFold = this.parentFold;\n    let diff = height - this._height;\n    parentFold ? parentFold.open && this.parent.updateFold(parentFold, diff) : this.edgeCheck(diff);\n    this.height = height;\n  }\n  /**\n   * Recalculate the boundaries of an Accordion and its descendants.\n   *\n   * This method should only be called if the width of a container changes,\n   * or a fold's contents have resized unexpectedly (such as when images load).\n   *\n   * @param {Boolean} allowSnap - Snap folds instantly into place without transitioning\n   */\n\n\n  refresh(allowSnap) {\n    let snap = allowSnap ? this.snapClass : false;\n    snap && this.el.classList.add(snap);\n    this.update();\n    if (this.childAccordions) this.childAccordions.forEach(a => a.parentFold.open ? a.refresh(allowSnap) : a.parentFold.needsRefresh = true);\n    snap && setTimeout(() => this.el.classList.remove(snap), 20);\n  }\n  /**\n   * Whether one of the Accordion's folds has been resized incorrectly.\n   *\n   * @type {Boolean}\n   * @readonly\n   * @property\n   */\n\n\n  get wrongSize() {\n    for (let i of this.folds) if (i.wrongSize) return true;\n\n    if (this.childAccordions) for (let i of this.childAccordions) if (i.wrongSize) return true;\n    return false;\n  }\n  /**\n   * Return the top-level ancestor this accordion's nested inside.\n   *\n   * @type {Accordion}\n   * @readonly\n   * @property\n   */\n\n\n  get root() {\n    let result = this;\n\n    while (result) {\n      if (!result.parent) return result;\n      result = result.parent;\n    }\n  }\n  /**\n   * Alter the rate at which screen-resize events update accordion widths.\n   *\n   * @param {Number} delay - Rate expressed in milliseconds\n   */\n\n\n  static setResizeRate(delay) {\n    let fn = function () {\n      for (let i of accordions) i.parent || i.disabled || i.refresh(true);\n    };\n\n    window.removeEventListener(\"resize\", this.onResize); // Make sure we weren't passed an explicit value of FALSE, or a negative value\n\n    if (false !== delay && (delay = +delay || 0) >= 0) {\n      this.onResize = delay ? debounce(fn, delay) : fn;\n      window.addEventListener(\"resize\", this.onResize);\n      if (delay) lastResizeRate = delay;\n    }\n  }\n  /**\n   * Return the closest (most deeply-nested) accordion enclosing an element.\n   *\n   * @param {Node} node\n   * @return {Accordion}\n   */\n\n\n  static getAccordion(node) {\n    while (node) {\n      if (\"accordion\" in node) return accordions[node.accordion];\n      node = node.parentNode;\n      if (!node || node.nodeType !== 1) return null;\n    }\n  }\n  /**\n   * Return the closest (most deeply-nested) fold enclosing an element.\n   *\n   * @param {Node} node\n   * @return {Fold}\n   */\n\n\n  static getFold(node) {\n    while (node) {\n      if (\"accordionFold\" in node) return folds[node.accordionFold];\n      node = node.parentNode;\n      if (!node || node.nodeType !== 1) return null;\n    }\n  }\n\n}\nAccordion.setResizeRate(25);\nwindow.Accordion = Accordion;","map":{"version":3,"sources":["C:/Users/turzm/equipment-page/src/components/Accordion/src/accordion.mjs"],"names":["transitionEnd","setToken","debounce","default","Fold","folds","accordions","activeAccordions","lastResizeRate","Accordion","constructor","el","options","index","push","openClass","closeClass","edgeClass","undefined","snapClass","enabledClass","disabledClass","modal","noAria","noKeys","noTransforms","heightOffset","useBorders","onToggle","i","Array","from","children","fold","prev","length","nextFold","previousFold","accordion","setAttribute","disabled","classList","add","update","next","parentNode","nodeType","getFold","parent","parentFold","remove","childAccordions","open","scrollHeight","distance","headingHeight","content","clientHeight","updateFold","addEventListener","onTransitionEnd","e","target","propertyName","getBoundingClientRect","bottom","window","innerHeight","input","_parent","result","_parentFold","_disabled","style","classes","height","removeEventListener","removeAttribute","setResizeRate","_height","edgeCheck","offset","box","windowEdge","y","fit","diff","refresh","allowSnap","snap","forEach","a","needsRefresh","setTimeout","wrongSize","root","delay","fn","onResize","getAccordion","node","accordionFold"],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport {transitionEnd, setToken, debounce} from \"./helpers.mjs\";\nimport {default as Fold, folds} from \"./fold.mjs\";\n\nconst accordions     = [];\nlet activeAccordions = 0;\nlet lastResizeRate;\n\n\n/**\n * Represents a column of collapsible content regions.\n * @class\n */\nexport default class Accordion {\n\n\t/**\n\t * Instantiate a new Accordion instance.\n\t *\n\t * @param {HTMLElement} el                    - Container wrapped around each immediate fold\n\t * @param {Object}      options               - Optional hash of settings\n\t * @param {String}      options.openClass     - CSS class controlling each fold's \"open\" state\n\t * @param {String}      options.closeClass    - CSS class used to mark a fold as closed\n\t * @param {String}      options.edgeClass     - CSS class toggled based on whether the bottom-edge is visible\n\t * @param {String}      options.snapClass     - CSS class for disabling transitions between window resizes\n\t * @param {String}      options.enabledClass  - CSS class marking an accordion as enabled\n\t * @param {String}      options.disabledClass - CSS class marking an accordion as disabled\n\t * @param {Boolean}     options.disabled      - Whether to disable the accordion on creation\n\t * @param {Boolean}     options.modal         - Whether to close the current fold when opening another\n\t * @param {Boolean}     options.noAria        - Disable the addition and management of ARIA attributes\n\t * @param {Boolean}     options.noKeys        - Disable keyboard navigation\n\t * @param {Boolean}     options.noTransforms  - Disable CSS transforms; positioning will be used instead\n\t * @param {Number}      options.heightOffset  - Distance to offset each fold by\n\t * @param {Boolean}     options.useBorders    - Consider borders when calculating fold heights\n\t * @param {Function}    options.onToggle      - Callback executed when opening or closing a fold\n\t * @constructor\n\t */\n\tconstructor(el, options){\n\t\tthis.index = accordions.push(this) - 1;\n\t\t\n\t\t// Parse options\n\t\toptions            = options || {};\n\t\tthis.openClass     = options.openClass  || \"open\";\n\t\tthis.closeClass    = options.closeClass || \"closed\";\n\t\tthis.edgeClass     = (undefined === options.edgeClass    ? \"edge-visible\" : options.edgeClass);\n\t\tthis.snapClass     = (undefined === options.snapClass    ? \"snap\"         : options.snapClass);\n\t\tthis.enabledClass  = (undefined === options.enabledClass ? \"accordion\"    : options.enabledClass);\n\t\tthis.disabledClass = options.disabledClass;\n\t\tthis.modal         = !!options.modal;\n\t\tthis.noAria        = !!options.noAria;\n\t\tthis.noKeys        = !!options.noKeys;\n\t\tthis.noTransforms  = !!options.noTransforms;\n\t\tthis.heightOffset  = +options.heightOffset || 0;\n\t\tthis.useBorders    = undefined === options.useBorders ? \"auto\" : options.useBorders;\n\t\tthis.onToggle      = options.onToggle;\n\t\t\n\t\t\n\t\t// Create a fold for each immediate descendant of the Accordion's container\n\t\tlet folds = [];\n\t\tfor(let i of Array.from(el.children)){\n\t\t\tlet fold = new Fold(this, i);\n\t\t\tfolds.push(fold);\n\t\t\t\n\t\t\t// Connect the fold to its previous sibling, if it's not the first to be added\n\t\t\tlet prev = folds[folds.length - 2];\n\t\t\tif(prev){\n\t\t\t\tprev.nextFold     = fold;\n\t\t\t\tfold.previousFold = prev;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tel.accordion    = this.index;\n\t\tthis.noAria || el.setAttribute(\"role\", \"tablist\");\n\t\tthis.el         = el;\n\t\tthis.folds      = folds;\n\n\t\t// Add .enabledClass early - it might affect the heights of each fold\n\t\tif(!options.disabled && this.enabledClass)\n\t\t\tel.classList.add(this.enabledClass);\n\t\t\n\t\tthis.update();\n\t\t\n\t\t\n\t\t// Find out if this accordion's nested inside another\n\t\tlet next = el;\n\t\twhile((next = next.parentNode) && 1 === next.nodeType){\n\t\t\tlet fold = Accordion.getFold(next);\n\t\t\tif(fold){\n\t\t\t\tlet accordion   = fold.accordion;\n\t\t\t\tthis.parent     = accordion;\n\t\t\t\tthis.parentFold = fold;\n\t\t\t\tthis.edgeClass && el.classList.remove(this.edgeClass);\n\t\t\t\t(accordion.childAccordions = accordion.childAccordions || []).push(this);\n\t\t\t\t(fold.childAccordions      = fold.childAccordions      || []).push(this);\n\n\t\t\t\t// Adjust the height of the containing fold's element\n\t\t\t\tif(fold.open){\n\t\t\t\t\tlet scrollHeight = fold.el.scrollHeight;\n\t\t\t\t\tlet distance     = (fold.headingHeight + fold.content.scrollHeight) - scrollHeight || (scrollHeight - fold.el.clientHeight);\n\t\t\t\t\taccordion.updateFold(fold, distance);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tthis.edgeClass && this.el.addEventListener(transitionEnd, this.onTransitionEnd = e => {\n\t\t\tif(!this.parent && e.target === el && \"height\" === e.propertyName && el.getBoundingClientRect().bottom > window.innerHeight)\n\t\t\t\tel.classList.remove(this.edgeClass);\n\t\t});\n\t\t\n\t\tthis.disabled = !!options.disabled;\n\t}\n\t\n\t\n\t/**\n\t * Get or set the accordion enclosing this one.\n\t *\n\t * @property\n\t * @type {Accordion}\n\t */\n\tset parent(input){ this._parent = input; }\n\tget parent(){\n\t\tlet result = this._parent;\n\t\tif(!result) return null;\n\t\t\n\t\t// Search for the first ancestor that *isn't* disabled\n\t\twhile(result){\n\t\t\tif(!result.disabled) return result;\n\t\t\tresult = result.parent;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\t/**\n\t * Get or set the fold of the accordion enclosing this one.\n\t *\n\t * @property\n\t * @type {Fold}\n\t */\n\tset parentFold(input){ this._parentFold = input; }\n\tget parentFold(){\n\t\tlet fold = this._parentFold;\n\t\tif(!fold) return null;\n\t\t\n\t\tlet accordion = fold.accordion;\n\t\t\n\t\t// Search for the first ancestor that *isn't* disabled\n\t\twhile(fold && accordion){\n\t\t\tif(!accordion.disabled) return fold;\n\t\t\tif(accordion = accordion.parent)\n\t\t\t\tfold = accordion.parentFold;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\t/**\n\t * Whether the accordion's been deactivated.\n\t *\n\t * @property\n\t * @type {Boolean}\n\t */\n\tget disabled(){ return this._disabled; }\n\tset disabled(input){\n\t\tif((input = !!input) !== this._disabled){\n\t\t\tconst el      = this.el;\n\t\t\tconst style   = el.style;\n\t\t\tconst classes = el.classList;\n\t\t\t\n\t\t\tthis.enabledClass  && setToken(classes, this.enabledClass,  !input);\n\t\t\tthis.disabledClass && setToken(classes, this.disabledClass,  input);\n\t\t\t\n\t\t\t\n\t\t\t// Deactivating\n\t\t\tif(this._disabled = input){\n\t\t\t\tstyle.height = null;\n\t\t\t\tthis.snapClass && classes.remove(this.snapClass);\n\t\t\t\tif(this.edgeClass){\n\t\t\t\t\tel.removeEventListener(transitionEnd, this.onTransitionEnd);\n\t\t\t\t\tclasses.remove(this.edgeClass);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(let i of this.folds)\n\t\t\t\t\ti.disabled = true;\n\t\t\t\t\n\t\t\t\tthis.noAria || el.removeAttribute(\"role\");\n\t\t\t\t--activeAccordions;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// Reactivating\n\t\t\telse{\n\t\t\t\tfor(let i of this.folds)\n\t\t\t\t\ti.disabled = false;\n\t\t\t\t\n\t\t\t\tthis.noAria || el.setAttribute(\"role\", \"tablist\");\n\t\t\t\t++activeAccordions;\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t\t\n\n\t\t\t\n\t\t\t// If there're no more active accordions, disable the onResize handler\n\t\t\tif(activeAccordions <= 0){\n\t\t\t\tactiveAccordions = 0;\n\t\t\t\tAccordion.setResizeRate(false);\n\t\t\t}\n\t\t\t\n\t\t\t// Otherwise, reactivate the onResize handler, assuming it was previously active\n\t\t\telse if(lastResizeRate)\n\t\t\t\tAccordion.setResizeRate(lastResizeRate);\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * Height of the accordion's container element.\n\t *\n\t * @property\n\t * @type {Number}\n\t */\n\tget height(){ return this._height; }\n\tset height(input){\n\t\tif(input && (input = +input) !== this._height){\n\t\t\tthis.el.style.height = input + \"px\";\n\t\t\tthis._height         = input;\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * Internal method to check if an accordion's bottom-edge is visible to the user (or about to be).\n\t *\n\t * @param {Number} offset\n\t * @private\n\t */\n\tedgeCheck(offset){\n\t\tlet edgeClass = this.edgeClass;\n\t\tif(edgeClass){\n\t\t\tlet box         = this.el.getBoundingClientRect();\n\t\t\tlet windowEdge  = window.innerHeight;\n\t\t\tlet classes     = this.el.classList;\n\t\t\t\n\t\t\t// If the bottom-edge is visible (or about to be), enable height animation\n\t\t\tif(box.bottom + (offset || 0) < windowEdge)\n\t\t\t\tclasses.add(edgeClass);\n\t\t\t\n\t\t\t// If the bottom-edge isn't visible anyway, disable height animation immediately\n\t\t\telse if(box.bottom > windowEdge)\n\t\t\t\tclasses.remove(edgeClass);\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * Update the vertical ordinate of each sibling for a particular fold.\n\t *\n\t * @param {Fold} fold\n\t * @param {Number} offset - Pixel distance to adjust by\n\t */\n\tupdateFold(fold, offset){\n\t\tlet next = fold;\n\t\tlet parentFold = this.parentFold;\n\t\t\n\t\twhile(next = next.nextFold)\n\t\t\tnext.y  += offset;\n\t\tparentFold || this.edgeCheck(offset);\n\t\tfold.height += offset;\n\t\tthis.height += offset;\n\t\t\n\t\tparentFold && parentFold.open && this.parent.updateFold(parentFold, offset);\n\t}\n\t\n\t\n\t/**\n\t * Update the height of each fold to fit its content.\n\t */\n\tupdate(){\n\t\tlet y = 0;\n\t\tlet height = 0;\n\t\tfor(let i of this.folds){\n\t\t\ti.y = y;\n\t\t\ti.fit();\n\t\t\ty      += i.height;\n\t\t\theight += i.height;\n\t\t}\n\t\t\n\t\tlet parentFold = this.parentFold;\n\t\tlet diff       = height - this._height;\n\t\tparentFold\n\t\t\t? (parentFold.open && this.parent.updateFold(parentFold, diff))\n\t\t\t: this.edgeCheck(diff);\n\t\t\n\t\tthis.height = height;\n\t}\n\t\n\t\n\t\n\t/**\n\t * Recalculate the boundaries of an Accordion and its descendants.\n\t *\n\t * This method should only be called if the width of a container changes,\n\t * or a fold's contents have resized unexpectedly (such as when images load).\n\t *\n\t * @param {Boolean} allowSnap - Snap folds instantly into place without transitioning\n\t */\n\trefresh(allowSnap){\n\t\tlet snap = allowSnap ? this.snapClass : false;\n\t\tsnap && this.el.classList.add(snap);\n\t\t\n\t\tthis.update();\n\t\tif(this.childAccordions)\n\t\t\tthis.childAccordions.forEach(a => a.parentFold.open\n\t\t\t\t? a.refresh(allowSnap)\n\t\t\t\t: (a.parentFold.needsRefresh = true));\n\t\t\n\t\tsnap && setTimeout(() => this.el.classList.remove(snap), 20);\n\t}\n\t\n\t\n\t\n\t/**\n\t * Whether one of the Accordion's folds has been resized incorrectly.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t * @property\n\t */\n\tget wrongSize(){\n\t\tfor(let i of this.folds)\n\t\t\tif(i.wrongSize) return true;\n\t\tif(this.childAccordions) for(let i of this.childAccordions)\n\t\t\tif(i.wrongSize) return true;\n\t\treturn false;\n\t}\n\t\n\t\n\t\n\t/**\n\t * Return the top-level ancestor this accordion's nested inside.\n\t *\n\t * @type {Accordion}\n\t * @readonly\n\t * @property\n\t */\n\tget root(){\n\t\tlet result = this;\n\t\twhile(result){\n\t\t\tif(!result.parent) return result;\n\t\t\tresult = result.parent;\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * Alter the rate at which screen-resize events update accordion widths.\n\t *\n\t * @param {Number} delay - Rate expressed in milliseconds\n\t */\n\tstatic setResizeRate(delay){\n\t\tlet fn = function(){\n\t\t\tfor(let i of accordions)\n\t\t\t\ti.parent || i.disabled || i.refresh(true);\n\t\t};\n\t\t\n\t\twindow.removeEventListener(\"resize\", this.onResize);\n\t\t\n\t\t// Make sure we weren't passed an explicit value of FALSE, or a negative value\n\t\tif(false !== delay && (delay = +delay || 0) >= 0){\n\t\t\tthis.onResize = delay ? debounce(fn, delay) : fn;\n\t\t\twindow.addEventListener(\"resize\", this.onResize);\n\t\t\tif(delay) lastResizeRate = delay;\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * Return the closest (most deeply-nested) accordion enclosing an element.\n\t *\n\t * @param {Node} node\n\t * @return {Accordion}\n\t */\n\tstatic getAccordion(node){\n\t\twhile(node){\n\t\t\tif(\"accordion\" in node)\n\t\t\t\treturn accordions[node.accordion];\n\t\t\t\n\t\t\tnode = node.parentNode;\n\t\t\tif(!node || node.nodeType !== 1) return null;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Return the closest (most deeply-nested) fold enclosing an element.\n\t *\n\t * @param {Node} node\n\t * @return {Fold}\n\t */\n\tstatic getFold(node){\n\t\twhile(node){\n\t\t\tif(\"accordionFold\" in node)\n\t\t\t\treturn folds[node.accordionFold];\n\t\t\t\n\t\t\tnode = node.parentNode;\n\t\t\tif(!node || node.nodeType !== 1) return null;\n\t\t}\n\t}\n}\n\n\nAccordion.setResizeRate(25);\nwindow.Accordion = Accordion;\n"]},"metadata":{},"sourceType":"module"}